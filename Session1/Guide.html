<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>A Guide to Erlang</title>
<link rel="stylesheet" type="text/css" href="./Guide_files/css">
<link href="./style/skeleton-style.css" rel="stylesheet" type="text/css">
<link href="./style/style.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="./style/erlang-style.css" type="text/css">
<style type="text/css">
<!--
.faded {
	color: #C0C000;
}
-->
</style>
</head>
<body>
<p class="mainHeader"><span class="head">A Guide to Erlang</span><br>
</p><table width="100%" border="0" cellspacing="0" cellpadding="4">
  <tbody><tr>
    <td valign="top"><ul>
      <li><a href="#about">About Erlang</a></li>
      <li><a href="#running">Running Erlang</a></li>
      <li><a href="#directives">Directives</a></li>
      <li><a href="#documentation">Documentation</a></li>
      <li><a href="#variables">Variables</a></li>
      <li><a href="#data_types">Data Types</a></li>
      <li><a href="#type_t_and_c">Type tests and conversions</a></li>
      <ul>
        <li><a href="#type_tests">Type tests</a></li>
        <li><a href="#type_conversions">Type conversions</a></li>
      </ul>
      <li><a href="#operations">Operations</a></li>
    </ul></td>
    <td valign="top"><ul>
      <li><a href="#pattern_matching">Pattern matching</a></li>
      <ul>
        <li><a href="#pm_expression">The pattern matching expression</a></li>
        <li><a href="#pm_examples">Examples</a></li>
        <li><a href="#pm_case">Case expressions</a></li>
        <li><a href="#pm_if">If expressions</a></li>
        <li><a href="#pm_guards">Guards</a></li>
      </ul>
      <li><a href="#defining_functions">Defining functions</a></li>
      <ul>
        <li><a href="#named_functions">Named functions</a></li>
        <li><a href="#recursion">Recursion</a></li>
        <li><a href="#anonymous_functions">Anonymous functions</a></li>
        <li><a href="#first_class">Functions as first-class objects</a></li>
      </ul>
      <li><a href="#lists">Lists</a></li>
      <li><a href="#list_ops">Selected operations on lists</a></li>
    </ul></td>
    <td valign="top"><ul>
      <li><a href="#string_ops">Selected operations on strings</a></li>
      <li><a href="#records">Records</a></li>
      <li><a href="#process_dictionary">The process dictionary</a></li>
      <li><a href="#concurrency">Concurrency</a></li>
      <li><a href="#exceptions">Exceptions</a></li>
      <li><a href="#io">Input/Output</a></li>
      <ul>
        <li><a href="#console_input">Input from the console</a></li>
        <li><a href="#console_output">Output to the console</a></li>
        <li><a href="#file_input">Input from a file</a></li>
        <li><a href="#file_output">Output to a file</a></li>
        <li><a href="#unix">Unix-like commands</a></li>
      </ul>
      <li><a href="#unit_testing">Unit testing</a></li>
    </ul></td>
  </tr>
</tbody></table>
<h1><a name="about"></a>About Erlang</h1>
<p>Erlang is an expression-oriented, single-assignment, garbage-collected, purely functional language. There are no loops, so recursion is heavily used.</p>
<p>Erlang is quite a small language. It is of interest primarily because of its approach to concurrency, using Actors. Actors have subsequently been incorporated into other languages, most importantly Clojure and Scala. Erlang is most suitable for building extremely reliable, fault-tolerant systems that do not need to be shut down in order to be upgraded. Its extremely convenient bit-manipulation makes it an excellent language for low-level communications.</p>
<h1><a name="running"></a>Running Erlang</h1>
<p>As with many languages, Erlang can be run in a REPL (Read-Eval-Print-Loop) "shell." Short pieces of code can be tested directly in the shell. To start the shell, enter <code>erl</code> at the command line. Within the shell,</p>
<ul>
  <li>Use&nbsp;&nbsp;&nbsp;<code>c(<em>module</em>.erl).</code>&nbsp;&nbsp;&nbsp;or&nbsp;&nbsp;&nbsp;&nbsp;<code>c(<em>module</em>).&nbsp;</code> to compile a module named <code class="variable">module</code> from the file <code><em>module</em>.erl</code>. The parameter to <code>c</code> should be an atom.</li>
  <li>Use&nbsp;&nbsp;&nbsp;<code>f().</code>&nbsp;&nbsp;&nbsp;to clear (forget) previous associations.</li>
  <li>Use the up and down arrows to choose a previous entry.</li>
  <li>Use control-C to exit the shell.</li>
</ul>
<p>Compared to the REPL for many other languages, Erlang's REPL is quite limited:</p>
<ul>
  <li>Directives beginning with a minus sign cannot be used in the REPL. In particular, you cannot <code>import</code> any files.</li>
  <li>Functions cannot be defined in the REPL.</li>
  <li>Except for a very few built-in functions,  function calls must be prefixed by the name of the module in which they are defined; for example, <code>lists:map(<em>args</em>)</code>, <code>my_module:my_function(<em>args</em>)</code>.</li>
</ul>
<h1><a name="directives"></a>Directives</h1>
<p>Every Erlang program should begin with a module directive, of the form<br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-module(<span class="variable">filename</span>).</code><br>
  and saved in a file with the name <code><span class="variable">filename</span>.erl</code>.</p>
<p>To provide functions defined in this file to other programs, use<br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-export([<span class="variable">function1</span>/<span class="variable">arity1</span>, ..., <span class="variable">functionN</span>/<span class="variable">arityN</span>]).</code><br>
  where the "arity" is the number of parameters expected by the function. </p>
<p>To use functions defined in another file, use<br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-import(<span class="variable">filename</span>, [<span class="variable">function1</span>/<span class="variable">arity1</span>, ..., <span class="variable">functionN</span>/<span class="variable">arityN</span>]).</code><br>
  where the "arity" is as above. Imported methods may be called without a<code> <span class="variable">filename</span>:</code> prefix.</p>
<p>To define a record:<br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-record(<span class="variable">Name</span>, {<span class="variable">Key1</span> = <span class="variable">Default1</span>, ..., <span class="variable">KeyN</span> = <span class="variable">DefaultN</span>}).</code><br>
  where the Keys are atoms; the default values are optional. Records may be defined in Erlang source files or  in files with the extension <code>.hrl</code>. , but may not be defined in the REPL.</p>
<p>To specify compiler options:<br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-compile(<em>Options</em>).</code><br>
  The <code>export_all</code> option is useful for debugging, but should be avoided in production code. </p>
<h1><a name="documentation"></a>Documentation</h1>
<p>Comments begin with a <code>%</code> character and continue to the end of the line.</p>
<p>Erlang used EDoc (inspired by Javadoc). EDoc comments go before a module or a function. Some of the tags that can be used for a module are <code>@author</code>, <code>@copyright</code>, <code>@deprecated</code>, <code>@doc</code> (followed by XHTML), and <code>@version</code>. Some of the tags that can be used for a function are <code>@deprecated</code>, <code>@doc</code> (followed by XHTML), <code>@private</code>, and <code>@spec</code>.</p>
<h1><a name="variables"></a>Variables</h1>
<p>Erlang is a single-assignment language. That is, once a variable has been given a value, it cannot be given a different value. In this sense it is like algebra rather than like most conventional programming languages.</p>
<p>Variables must begin with a capital letter or an underscore, and are composed of letters, digits, and underscores.</p>
<p>The special variable <code>_</code> is a "don't care" variable--it does not retain its value. It is as if every occurrance of <code>_</code> is a new, different variable.</p>
<p>Erlang issues a warning if a variable occurs only once in a function. To eliminate this warning, use an underscore as the first character of the variable name.</p>
<h1><a name="data_types"></a>Data types</h1>
<p>Erlang has:</p>
<ul>
  <li><strong>Integers</strong>, of unlimited size: <code>1112223344455666777888999000</code>.
    <ul>
      <li>Integers may be written in any base from 2 to 36, with the syntax<code> <span class="variable">base</span>#<span class="variable">number</span></code>, for example, <code>16#3FF</code> is 1023.</li>
      <li>The ASCII value of characters can be written as <code>$<span class="variable">c</span></code>, for example, <code>$A</code> is 65, and <code>$\n</code> is 10.</li>
    </ul>
  </li>
  <li><strong>Floats</strong>: <code>1234.5678</code>, <code>6.0221415e23</code>.</li>
  <li><strong>Strings</strong>, enclosed in double quotes: <code>"This is a string."</code>
    <ul>
      <li>A string is implemented as a list of ASCII (integer) values; how it is printed depends on whether it contains non-ASCII values.</li>
      <li>Erlang has no Unicode support, but Unicode strings can be represented as a list of integers.</li>
      <li>Standard escape sequences, such as <code>\n</code> and <code>\t</code>, may be used in strings.</li>
    </ul>
  </li>
  <li><strong>Atoms</strong>. An atom stands for itself. It begins with a lowercase letter and is composed of letters, digits, and underscores, or it is any string enclosed in single quotes: <code>atom1</code>, <code>'Atom&nbsp;2'</code>.
    <ul>
      <li>Erlang has no separate "boolean" type, but uses the atoms <code>true</code> and <code>false</code> to represent boolean values.</li>
    </ul>
  </li>
  <li><strong>Lists</strong>, which are a comma-separated sequence of values enclosed in brackets: <code>[abc, 123, "pigs in a tree"]</code>.</li>
  <li><strong>Tuples</strong>, which are a comma-separated sequence of values enclosed in braces:<code> {abc, 123, "pigs in a tree"}</code>.
    <ul>
      <li>Because the values in tuples are "anonymous," a common technique is to use name-value pairs, with the name being an atom: <code>{{name, "Pat"}, {age, 27}, {gender, female}}</code>.</li>
    </ul>
  </li>
  <li><strong>Records</strong>, which are not a separate data type, but are just tuples with keys associated with each value. They are declared in a file and defined (given specific values) in the program.</li>
  <li><strong>Binaries</strong>, enclosed in double angle brackets: <code>&lt;&lt;0, 255, 128, 128&gt;&gt;</code>, <code>&lt;&lt;"hello"&gt;&gt;</code>, <code>&lt;&lt;X:3, Y:7, Z:6&gt;&gt;</code>. Binaries are sequences of bits; the number of bits in a binary must be a multiple of 8.
    <ul>
      <li>Erlang has extremely good support for binaries, most of which is beyond the scope of this paper.</li>
    </ul>
  </li>
  <li><strong>References</strong> are globally unique values, created by calling <code>make_ref()</code>.</li>
  <li><strong>Process identifiers</strong> (<strong>Pids</strong>) are the "names" of processes.</li>
</ul>
<h1><a name="type_t_and_c"></a>Type tests and conversions</h1>
<p>To test for or convert "strings," recall that strings are actually lists of integers.</p>
<h2><a name="type_tests"></a>Type tests</h2>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
  <tbody><tr>
    <td><code>is_atom(<span class="variable">X</span>)</code></td>
    <td><code>is_function(<span class="variable">X</span>)</code></td>
    <td><code>is_number(<span class="variable">X</span>)</code></td>
    <td><code>is_tuple(<span class="variable">X</span>)</code></td>
  </tr>
  <tr>
    <td><code>is_binary(<span class="variable">X</span>)</code></td>
    <td><code>is_function(<span class="variable">X</span>, <span class="variable">N</span>)</code></td>
    <td><code>is_pid(<span class="variable">X</span>)</code></td>
    <td><code>is_record(<span class="variable">X</span>)</code></td>
  </tr>
  <tr>
    <td><code>is_constant(<span class="variable">X</span>)</code></td>
    <td><code>is_integer(<span class="variable">X</span>)</code></td>
    <td><code>is_port(<span class="variable">X</span>)</code></td>
    <td><code>is_record(<span class="variable">X</span>, <span class="variable">Tag</span>)</code></td>
  </tr>
  <tr>
    <td><code>is_float(<span class="variable">X</span>)</code></td>
    <td><code>is_list(<span class="variable">X</span>)</code></td>
    <td><code>is_reference(<span class="variable">X</span>)</code></td>
    <td><code>is_record(<span class="variable">X</span>, <span class="variable">Tag</span>, <span class="variable">N</span>)</code></td>
  </tr>
</tbody></table>
<h2><a name="type_conversions"></a>Type conversions</h2>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tbody><tr>
    <td><code>atom_to_list(<span class="variable">Atom</span>)</code></td>
    <td><code>float_to_list(<span class="variable">Float</span>)</code></td>
    <td><code>list_to_binary(<span class="variable">List</span>)</code></td>
    <td><code>round(<span class="variable">Float</span>)</code></td>
  </tr>
  <tr>
    <td><code>binary_to_list(<span class="variable">Binary</span>)</code></td>
    <td><code>integer_to_list(<span class="variable">Integer</span>)</code></td>
    <td><code>list_to_integer(<span class="variable">List</span>)</code></td>
    <td><code>trunc(<span class="variable">Float</span>)</code></td>
  </tr>
  <tr>
    <td><code>float(<span class="variable">Integer</span>)</code></td>
    <td><code>list_to_atom(<span class="variable">List</span>)</code></td>
    <td><code>list_to_tuple(<span class="variable">List</span>)</code></td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td><code>float(<span class="variable">List</span>)</code></td>
    <td><code>list_to_existing_atom(<span class="variable">List</span>)</code></td>
    <td><code>tuple_to_list(<span class="variable">Tuple</span>)</code></td>
    <td>&nbsp;</td>
  </tr>
</tbody></table>
<h1><a name="operations"></a>Operations</h1>
<table width="99%" cellpadding="4" bgcolor="#FFFFFF" class="layout">
  <tbody><tr bgcolor="#FFFFFF">
    <td valign="top" bgcolor="#FFFFFF"><table border="1" cellspacing="0" class="data">
        <tbody><tr>
          <th colspan="2" scope="col">Arithmetic operations</th>
        </tr>
        <tr>
          <th scope="col">Operation</th>
          <th scope="col">Description</th>
        </tr>
        <tr>
          <td><code>+<span class="variable">X</span></code></td>
          <td>unary plus</td>
        </tr>
        <tr>
          <td><code>-<span class="variable">X</span></code></td>
          <td>unary minus</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> * <span class="variable">Y</span></code></td>
          <td><p>multplication</p></td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> / <span class="variable">Y</span></code></td>
          <td>division (yields a float)</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> div <span class="variable">Y</span></code></td>
          <td>integer division</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> rem <span class="variable">Y</span></code></td>
          <td>remainder</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> + <span class="variable">Y</span></code></td>
          <td>addition</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> - <span class="variable">Y</span></code></td>
          <td>subtraction</td>
        </tr>
      </tbody></table></td>
    <td valign="top"><table border="1" cellspacing="0" class="data">
        <tbody><tr>
          <th colspan="2" scope="col">Term Comparisons</th>
        </tr>
        <tr>
          <th scope="col">Comparison</th>
          <th scope="col">Description</th>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> &lt; <span class="variable">Y</span></code></td>
          <td>less than</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> =&lt; <span class="variable">Y</span></code></td>
          <td>equal or less than (<strong>not<code> <span class="variable">X</span> &lt;= <span class="variable">Y</span></code> !</strong>)</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> == <span class="variable">Y</span></code></td>
          <td rowspan="2"><p>equal and not equal; use only for comparing integers and floats</p></td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> /= <span class="variable">Y</span></code></td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> &gt;= <span class="variable">Y</span></code></td>
          <td>greater or equal</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> &gt; <span class="variable">Y</span></code></td>
          <td>greater</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> =:= <span class="variable">Y</span></code></td>
          <td>equal/identical to</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> =/= <span class="variable">Y</span></code></td>
          <td>unequal/not identical to</td>
        </tr>
      </tbody></table>
      Any term may be compared with any other term. The ordering is: <code>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; binary</code>.</td>
  </tr>
  <tr bgcolor="#FFFFFF">
    <td bgcolor="#FFFFFF"><table border="1" cellspacing="0" class="data">
        <tbody><tr>
          <th colspan="2" scope="col">Boolean operations</th>
        </tr>
        <tr>
          <th scope="col">Operation</th>
          <th scope="col">Description</th>
        </tr>
        <tr>
          <td><code>not <span class="variable">X</span></code></td>
          <td> not</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> and <span class="variable">Y</span></code></td>
          <td> and</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> or <span class="variable">Y</span></code></td>
          <td><p> or</p></td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> xor <span class="variable">Y</span></code></td>
          <td> exclusive or</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> andalso <span class="variable">Y</span></code></td>
          <td>short-circuit and<span class="variable"></span></td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> orelse <span class="variable">Y</span></code></td>
          <td>short-circuit or<span class="variable"></span></td>
        </tr>
      </tbody></table></td>
    <td valign="top"><table border="1" cellspacing="0" class="data">
        <tbody><tr>
          <th colspan="2" scope="col">Bitwise operations</th>
        </tr>
        <tr>
          <th scope="col">Operation</th>
          <th scope="col">Description</th>
        </tr>
        <tr>
          <td><code>bnot <span class="variable">X</span></code></td>
          <td>bitwise not</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> band <span class="variable">Y</span></code></td>
          <td>bitwise and</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> bor <span class="variable">Y</span></code></td>
          <td><p>bitwise or</p></td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> bxor <span class="variable">Y</span></code></td>
          <td>bitwise exclusive or</td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> bsl <span class="variable">N</span></code></td>
          <td>bitshift left by <span class="variable">N</span></td>
        </tr>
        <tr>
          <td><code><span class="variable">X</span> bsr <span class="variable">N</span></code></td>
          <td>bitshift right by <span class="variable">N</span></td>
        </tr>
      </tbody></table></td>
  </tr>
</tbody></table>
<h1><a name="pattern_matching"></a>Pattern matching</h1>
<h2><a name="pm_expression"></a>The pattern matching expression</h2>
<p>Pattern matching is the fundamental operation in Erlang. A simple pattern matching expression looks like an assignment statement in other languages:<br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">pattern</span> = <span class="variable">expression</span>.</code><br>
  This says to evaluate the expression, and try to match the result to the pattern. In this context, it is an error if the pattern match does not succeed. Note that every statement in Erlang ends with a period.</p>
<p>In general, pattern matching succeeds in the following cases:</p>
<ul>
  <li>The pattern is an unbound variable. When the pattern match succeeds, the variable is bound to the value of the expression.</li>
  <li>The pattern is bound to a value, and the expression evaluates to the same value.</li>
  <li>The pattern is a structure (list or tuple) which may contain unbound variables, and the expression results in the same structure; when the pattern match succeeds, the unbound variables become bound to the corresponding parts of the evaluated expression.</li>
</ul>
<h3><a name="pm_examples"></a>Examples</h3>
<dl>
  <dt><code><span class="variable">Variable</span> = <span class="variable">expression</span>.</code></dt>
  <dd>The expression is evaluated.
    <ul>
      <li>If the <span class="variable">Variable</span> has no previous value, it is given the value of the expression; this makes the two sides equal, so the pattern match succeeds.</li>
      <li>If the <span class="variable">Variable</span> has a previous value, and it is equal to the value of the expression, then the pattern match succeeds, otherwise it fails.</li>
    </ul>
  </dd>
  <dt><code>[<span class="variable">H</span>|<span class="variable">T</span>] = <span class="variable">expression</span>.</code></dt>
  <dd>If the value of the expression is a nonempty list, <span class="variable">H</span> is matched against the head of the list (the first element) and <span class="variable">T</span> is matched against the tail of the list (the remaining elements). If either fails to match, or if the expression does not evaluate to a nonempty list, the pattern match fails. Note that <span class="variable">H</span> and <span class="variable">T</span> may be variables, literals, or expressions.</dd>
  <dt><code>[<span class="variable">H<sub>1</sub>, H<sub>2</sub>, ..., H<sub>N</sub></span>|<span class="variable">T</span>] = <span class="variable">expression</span>.</code></dt>
  <dd><code><span class="variable">H<sub>1</sub>, H<sub>2</sub>, ..., H<sub>N</sub></span></code> are matched against the first <span class="variable">N</span> elements of the list, and <span class="variable">T</span> is matched against the remaining elements. If any part fails to match, the pattern match fails.</dd>
  <dt><code>{<span class="variable">A</span>, <span class="variable">B</span>, <span class="variable">C</span>} = {<span class="variable">X</span>, <span class="variable">Y</span>, <span class="variable">Z</span>}.</code></dt>
  <dd>The expressions on the right are evaluated and compared, in order, against the patterns on the left (that is, <span class="variable">A</span><code>=<span class="variable">X</span></code>, <span class="variable">B</span><code>=<span class="variable">Y</span></code>, <code><span class="variable">C</span>=<span class="variable">Z</span></code><span class="variable"></span>). In order for the pattern match to succeed, the tuples must be the same length, and corresponding parts must match.</dd>
  <dt><code>#<span class="variable">Name</span>{<span class="variable">Key</span> = <span class="variable">Variable</span>, ..., <span class="variable">Key</span> = <span class="variable">Variable</span>} = <span class="variable">Record</span>.</code></dt>
  <dd>The <span class="variable">Variable</span>s are matched against the values of the named <span class="variable">Key</span>s in the <span class="variable">Record</span>.</dd>
  <dt><code>&lt;&lt;<span class="variable">Pattern</span>:<span class="variable">Size</span>, ..., <span class="variable">Pattern</span>:<span class="variable">Size</span>&gt;&gt; = <span class="variable">Binary</span>.</code></dt>
  <dd>The values in the <span class="variable">Binary</span> are unpacked into their component parts and matched against the <span class="variable">Pattern</span>s.</dd>
  <dd>&nbsp;</dd>
</dl>
<h2><a name="pm_case"></a>Case expressions</h2>
<p>The <code>case</code> expression uses pattern matching, and has the following syntax:</p>
<blockquote>
  <pre>case <span class="variable">Expression</span> of<br>    <span class="variable">Pattern1</span> <span class="faded">[</span>when <span class="variable">Guard1</span><span class="faded">]</span> -&gt; <span class="variable">Expression_sequence1</span>;<br>    <span class="variable">Pattern2</span> <span class="faded">[</span>when <span class="variable">Guard2</span><span class="faded">]</span> -&gt; <span class="variable">Expression_sequence2</span>;<br>    ...<br>    <span class="variable">PatternN</span> <span class="faded">[</span>when <span class="variable">GuardN</span><span class="faded">]</span> -&gt; <span class="variable">Expression_sequenceN</span><br>end</pre>
</blockquote>
<p>The brackets indicate that the <code>when</code> part (which is just a condition) is optional. The expression is evaluated, and the patterns are tried, in order. When a matching pattern is found (and whose associated guard, if present, is true), the corresponding expression sequence is evaluated. The value of an expression sequence is the value of the last expression, and that becomes the value of the <code>case</code>. </p>
<h2><a name="pm_if"></a>If expressions</h2>
<p>The <code>if</code> expression is like a <code>case</code> expression without the pattern matching.</p>
<blockquote>
  <pre>if<br>    <span class="variable">Guard1</span> -&gt;<br>        <span class="variable">Expression_sequence1</span>;<br>    <span class="variable">Guard2</span> -&gt;<br>        <span class="variable">Expression_sequence2</span>;<br>    ...<br>    <span class="variable">GuardN</span> -&gt;<br>        <span class="variable">Expression_sequenceN</span><br>end</pre>
</blockquote>
<p>The value of the <code>if</code> expression is the value of the expression sequence that is chosen. The value of an expression sequence is the value of the last expression executed. It is an error if no guard succeeds; hence, it is common to use <code>true</code> as the last guard.</p>
<h2><a name="pm_guards"></a>Guards</h2>
<p>Guards may not have side effects. To ensure this, user-defined functions are not allowed in guards. Things that may be uses are: type tests, boolean operators, bitwise operators, arithmetic operators, relational operators, and the following BIFs (Built In Functions):</p>
<table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tbody><tr>
    <td><code>abs(<span class="variable">Number</span>)</code></td>
    <td><code>hd(<span class="variable">List</span>)</code></td>
    <td><code>node(<span class="variable">X</span>)</code></td>
    <td><code>size(<span class="variable">TupleOrBinary</span>)</code></td>
  </tr>
  <tr>
    <td><code>element(<span class="variable">Integer</span>, <span class="variable">Tuple</span>)</code></td>
    <td><code>length(<span class="variable">List</span>)</code></td>
    <td><code>round(<span class="variable">Number</span>)</code></td>
    <td><code>trunc(<span class="variable">Number</span>)</code></td>
  </tr>
  <tr>
    <td><code>float(<span class="variable">Number</span>)</code></td>
    <td><code>node()</code></td>
    <td><code>self()</code></td>
    <td><code>tl(<span class="variable">List</span>)</code></td>
  </tr>
</tbody></table>
<h1><a name="defining_functions"></a>Defining functions</h1>
<p>A function is a value, or <span class="definiendum">first-class object</span>. That means it can be assigned to a variable, or given as an argument to a function, or returned as the value of a function. </p>
<h2><a name="named_functions"></a>Named functions</h2>
<p>The syntax for a named function is a series of one or more clauses:</p>
<blockquote>
  <pre><span class="variable">name</span>(<span class="variable">Patterns1</span>) -&gt; <span class="variable">Body1</span>;<br><span class="variable">name</span>(<span class="variable">Patterns2</span>) -&gt; <span class="variable">Body2</span>;<br>...<br><span class="variable">name</span>(<span class="variable">PatternsN</span>) -&gt; <span class="variable">BodyN</span>.</pre>
</blockquote>
where
<ul>
  <li>The <span class="variable">name</span> and the <span class="definiendum">arity</span> (number of patterns given as  parameters) are the same for each clause.</li>
  <li>Clauses are tried in order until one of the parameter lists (sequence of patterns) matches, then the corresponding Body is evaluated.</li>
  <li>Each Body consists of an  sequence of expressions, separated by commas; the value of the sequence, and therefore the value of the function, is the value of the last expression evaluated.</li>
  <li>It is an error if no parameter list matches.</li>
</ul>
<h2><a name="recursion"></a>Recursion</h2>
<p><span class="definiendum">Recursion</span> is when a function calls itself, either directly (<code>f</code> calls <code>f</code>) or indirectly (<code>f</code> calls <code>g</code>, which calls <code>h</code>, ..., which calls <code>f</code>). Any program which uses a loop can be rewritten to use recursion, and vice versa. Erlang has no loops, therefore recursion is used heavily.</p>
<p>Here is one way to write the equivalent of a loop in Erlang:</p>
<blockquote>
  <pre>myFunction(args1) -&gt;<br>    args2 = SomeExpression(args1);<br>    myFunction(args2).</pre>
</blockquote>
<p><span class="definiendum">Tail recursion</span> is when the recursive call is the very last thing done in the function. As an example, the usual definition of the factorial function,<br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;factorial(0) -&gt; 1;<br>
  &nbsp;&nbsp;&nbsp;&nbsp;factorial(N) -&gt; N * factorial(N - 1).</code><br>
  is <em>not</em> tail recursive, because a multiplication is performed <em>after</em> the recursive call.</p>
<p>In general, each recursive call adds information to an internal stack; <em>very</em> deep recursions can cause Erlang to run out of memory. Tail recursion is desirable because the compiler can easily change a tail recursion into a loop, which does not add information to the stack, and therefore does not cause memory problems.</p>
<p>Functions that are not tail recursive (such as <code>factorial</code>) can usually be rewritten as tail recursive functions, with the aid of a helper function. As with many optimizations, this is <em>not recommended</em> until proven necessary, because the resultant code is harder to read and understand.</p>
<h2><a name="anonymous_functions"></a>Anonymous functions</h2>
<p>The syntax for an anonymous function is </p>
<blockquote>
  <pre>fun(<span class="variable">Patterns1</span>) -&gt; <span class="variable">Body1</span>;<br>   (<span class="variable">Patterns2</span>) -&gt; <span class="variable">Body2</span>;<br>   ...<br>   (<span class="variable">PatternsN</span>) -&gt; <span class="variable">BodyN</span><br>end</pre>
</blockquote>
<h2><a name="first_class"></a>Functions as first-class objects</h2>
<p>Functions are values. That is, they may be assigned to variables, passed as arguments to functions, and returned as the result of functions. </p>
<p>An anonymous function may be used as a literal value. A named function may be referred to by using the syntax <code>fun&nbsp;<span class="variable">FunctionName</span>/<span class="variable">Arity</span></code>.</p>
<h1><a name="lists"></a>Lists</h1>
<p>A list literal can be written as a bracketed, comma-separated list of values. The values may be of different types. Example: <code>[5,&nbsp;"abc",&nbsp;[3.2,&nbsp;{a,&nbsp;&lt;&lt;255&gt;&gt;}]</code>.</p>
<p>A <span class="definiendum">list comprension</span> has the syntax <code>[<span class="variable">Expression</span>&nbsp;||&nbsp;<span class="variable">Generator</span>,&nbsp;<span class="variable">GuardOrGenerator</span>,&nbsp;...,&nbsp;<span class="variable">GuardOrGenerator</span>]</code><br>
  where </p>
<ul>
  <li>The <span class="variable">Expression</span> typically makes use of variables defined by a <span class="variable">Generator</span>,</li>
  <li>A <span class="variable">Generator</span> provides a sequence of values; it has the form<code> <span class="variable">Pattern</span> &lt;- <span class="variable">List</span></code>,</li>
  <li>A <span class="variable">Guard</span> is a test that determines whether the value will be used in the <span class="variable">Expression</span>.</li>
  <li>At least one <span class="variable">Generator</span> is required; <span class="variable">Guard</span>s and additional <span class="variable">Generator</span>s are optional.</li>
</ul>
<p>Example list comprehension:<br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N = [1, 2, 3, 4, 5].<br>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L = [10 * X + Y || X &lt;- N, Y &lt;- N, X &lt; Y].&nbsp;<span class="comment">&nbsp;%&nbsp;Result is [12,13,14,15,23,24,25,34,35,45]</span></code></p>
<p><code>hd(<span class="variable">L</span>)</code> returns the first element in the list <span class="variable">L</span>; <code>tl(<span class="variable">L</span>) </code>returns the list of remaining elements.</p>
<h1><a name="list_ops"></a>Selected operations on lists</h1>
<p>The following operations are predefined.</p>
<ul>
  <li><code>hd(<span class="variable">List</span>) -&gt; <span class="variable">Element</span></code>-- Returns the first element of the list.</li>
  <li><code>tl(<span class="variable">List</span>) -&gt; <span class="variable">List</span></code> -- Returns the list minus its first element.</li>
  <li><code>length(<span class="variable">List</span>) -&gt; <span class="variable">Integer</span></code> -- returns the length of the list.</li>
</ul>
<p>The following functions are in the <code>lists</code> module. To call them, either first <code>import</code> them, or prepend <code>lists:</code> to the function call.The definitions are copied from <a href="http://www.erlang.org/doc/man/lists.html">http://www.erlang.org/doc/man/lists.html</a>. Of these, the operations <code>map</code>, <code>filter</code>, <code>foldl</code>, and <code>seq</code> are the most commonly used.</p>
<ul>
  <li><code>all(<span class="variable">Pred</span>, <span class="variable">List</span>) -&gt; bool()</code> -- Returns true if Pred(Elem) returns true for all elements Elem in List, otherwise false.</li>
  <li><code>any(<span class="variable">Pred</span>, <span class="variable">List</span>) -&gt; bool()</code> -- Returns true if Pred(Elem) returns true for at least one element Elem in List.</li>
  <li><code>append(<span class="variable">List1</span>, <span class="variable">List2</span>) -&gt; <span class="variable">List3</span></code> -- Returns a new list List3 which is made from the elements of List1 followed by the elements of List2.
    <ul>
      <li><code>lists:append(<span class="variable">A</span>, <span class="variable">B</span>)</code> is equivalent to <code><span class="variable">A</span> ++ <span class="variable">B</span></code>.</li>
    </ul>
  </li>
  <li><code>dropwhile(<span class="variable">Pred</span>, <span class="variable">List1</span>) -&gt; <span class="variable">List2</span></code> -- Drops elements Elem from List1 while Pred(Elem) returns true and returns the remaining list.</li>
  <li><code>filter(<span class="variable">Pred</span>, <span class="variable">List1</span>) -&gt; <span class="variable">List2</span></code> -- List2 is a list of all elements Elem in List1 for which Pred(Elem) returns true.
    <ul>
      <li>Example: <code>lists:filter(fun(X) -&gt; X =&lt; 3 end, [3, 1, 4, 1, 6]). <span class="comment">% Result is  [3,1,1]</span></code></li>
    </ul>
  </li>
  <li><code>flatmap(<span class="variable">Fun</span>, <span class="variable">List1</span>) -&gt; <span class="variable">List2</span></code> -- Maps Fun to List1 and flattens the result.</li>
  <li><code>flatten(<span class="variable">DeepList</span>) -&gt; <span class="variable">List</span></code> -- Returns a flattened version of DeepList.</li>
  <li><code>foldl(<span class="variable">Fun</span>, <span class="variable">Acc0</span>, <span class="variable">List</span>) -&gt; <span class="variable">Acc1</span></code> -- Calls Fun(Elem, AccIn) on successive elements A of List, starting with AccIn == Acc0. Fun/2 must return a new accumulator which is passed to the next call. The function returns the final value of the accumulator. Acc0 is returned if the list is empty.
    <ul>
      <li>Example: <code>lists:foldl(fun(X, Y) -&gt; X + 10 * Y end, 0, [1, 2, 3, 4, 5]). <span class="comment">% Result is 12345</span></code></li>
    </ul>
  </li>
  <li><code>foreach(<span class="variable">Fun</span>, <span class="variable">List</span>) -&gt; void()</code> -- Calls Fun(Elem) for each element Elem in List. This function is used for its side effects and the evaluation order is defined to be the same as the order of the elements in the list.</li>
  <li><code>map(<span class="variable">Fun</span>, <span class="variable">List1</span>) -&gt; <span class="variable">List2</span></code> -- Takes a function from As to Bs, and a list of As and produces a list of Bs by applying the function to every element in the list. This function is used to obtain the return values. The evaluation order is implementation dependent.
    <ul>
      <li>Example: <code>lists:map(fun(X) -&gt; 2 * X end, [1, 2, 3]). <span class="comment">% Result is  [2,4,6]</span></code></li>
    </ul>
  </li>
  <li><code>member(<span class="variable">Elem</span>, <span class="variable">List</span>) -&gt; <span class="variable">bool</span>()</code> -- Returns true if Elem matches some element of List, otherwise false.</li>
  <li><code>partition(<span class="variable">Pred</span>, <span class="variable">List</span>) -&gt; {<span class="variable">Satisfying</span>, <span class="variable">NonSatisfying</span>}</code> -- Partitions List into two lists, where the first list contains all elements for which Pred(Elem) returns true, and the second list contains all elements for which Pred(Elem) returns false.</li>
  <li><code>reverse(<span class="variable">List1</span>) -&gt; <span class="variable">List2</span></code> -- Returns a list with the top level elements in List1 in reverse order, with the tail Tail appended.</li>
  <li><code>seq(<span class="variable">From</span>, <span class="variable">To</span>) -&gt; <span class="variable">Seq</span></code> -- Returns a sequence of  integers from From to To, inclusive.</li>
  <li><code>seq(<span class="variable">From</span>, <span class="variable">To</span>, <span class="variable">Incr</span>) -&gt; <span class="variable">Seq</span></code> -- Returns a sequence of integers which starts with From  and contains the successive results of adding Incr to the previous element, until To has been reached or passed (in the latter case, To is not an element of the sequence).</li>
  <li><code>sort(<span class="variable">List1</span>) -&gt; <span class="variable">List2</span></code> -- Returns a list containing the sorted elements of List1.</li>
  <li><code>takewhile(<span class="variable">Pred</span>, <span class="variable">List1</span>) -&gt; <span class="variable">List2</span></code> -- Takes elements Elem from List1 while Pred(Elem) returns true, that is, the function returns the longest prefix of the list for which all elements satisfy the predicate.</li>
  <li><code>unzip(<span class="variable">List1</span>) -&gt; {<span class="variable">List2</span>, <span class="variable">List3</span>}</code> -- "Unzips" a list of two-tuples into two lists, where the first list contains the first element of each tuple, and the second list contains the second element of each tuple.</li>
  <li><code>zip(<span class="variable">List1</span>, <span class="variable">List2</span>) -&gt; <span class="variable">List3</span></code> -- "Zips" two lists of equal length into one list of two-tuples, where the first element of each tuple is taken from the first list and the second element is taken from corresponding element in the second list.</li>
</ul>
<h1><a name="string_ops"></a>Selected operations on strings</h1>
<p>Strings are lists of ASCII values, so all the list operations apply. The following are in the <code>string</code> module, so either <code>import</code> them or prepend each function call with <code>string:</code>.The definitions are copied from <a href="http://www.erlang.org/doc/man/string.html">http://www.erlang.org/doc/man/string.html</a>.</p>
<ul>
  <li><code>len(<em>String</em>) -&gt; <em>Length</em></code> -- Returns the number of characters in the string.</li>
  <li><code>equal(<em>String1</em>, <em>String2</em>) -&gt; bool()</code> -- Tests whether two strings are equal.</li>
  <li><code>chr(<em>String</em>, <em>Character</em>) -&gt; <em>Index</em></code> -- Returns the (1-based) index of the first occurrence of Character in String. 0 is returned if Character does not occur.</li>
  <li><code>rchr(<em>String</em>, <em>Character</em>) -&gt; <em>Index</em></code> -- Returns the (1-based) index of the last occurrence of Character in String. 0 is returned if Character does not occur.</li>
  <li><code>str(<em>String</em>, <em>SubString</em>) -&gt; <em>Index</em></code> -- Returns the (1-based) position where the first occurrence of SubString begins in String. 0 is returned if SubString does not exist in String.</li>
</ul>
<ul>
  <li><code>rstr(<em>String</em>, <em>SubString</em>) -&gt; <em>Index</em></code> -- Returns the (1-based) position where the last occurrence of SubString begins in String. 0 is returned if SubString does not exist in String.</li>
  <li><code>substr(<em>String</em>, <em>Start</em>) -&gt; <em>Substring</em></code> -- Returns a substring of String, starting at the position Start, and ending at the end of the string.</li>
  <li><code>substr(<em>String</em>, <em>Start</em>, <em>Length</em>) -&gt; <em>Substring</em></code> -- Returns a substring of String, starting at the position Start, and ending at  length Length.</li>
  <li><code>strip(<em>String</em>) -&gt; <em>Stripped</em></code> -- Returns a string where the leading and trailing blanks have been removed.</li>
  <li><code>to_float(<span class="variable">String</span>) -&gt; {<span class="variable">Float</span>,<span class="variable">Rest</span>} | {error,<span class="variable">Reason</span>}</code> -- Argument String is expected to start with a valid text represented float (the digits being ASCII values). Remaining characters in the string after the float are returned in Rest.</li>
  <li><code>to_integer(<span class="variable">String</span>) -&gt; {<span class="variable">Int</span>,<span class="variable">Rest</span>} | {error,<span class="variable">Reason</span>}</code> -- Argument String is expected to start with a valid text represented integer (the digits being ASCII values). Remaining characters in the string after the integer are returned in Rest.</li>
  <li><code>to_lower(<em>String</em>) -&gt; <em>Result</em></code> -- Returns a string in which uppercase characters have been converted to lowercase.</li>
  <li><code>to_upper(<em>String</em>) -&gt; <em>Result</em></code> -- Returns a string in which lowercase characters have been converted to uppercase.</li>
</ul>
<h1><a name="records"></a>Records</h1>
<p>Records are declared in a file with the syntax <code>-record(<span class="variable">Name</span>, {<span class="variable">Key1</span> = <span class="variable">Default1</span>, ..., <span class="variable">KeyN</span> = <span class="variable">DefaultN</span>}).</code></p>
<p>To read the record declarations from a file, use the function <code>rr("<span class="variable">records</span>.hrl")</code>.</p>
<p>To define a record, use the syntax<br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">Variable1</span> = #<span class="variable">Name</span>{<span class="variable">Key</span> = <span class="variable">Value</span>, ..., <span class="variable">Key</span> = <span class="variable">Value</span>}.</code></p>
<p> The default value is used for any omitted <code><span class="variable">Key</span>=<span class="variable">Value</span></code> pairs. A new, modified record may be created with the syntax<br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">Variable2</span> = <span class="variable">Variable1</span>#<span class="variable">Name</span>{<span class="variable">Key</span> = <span class="variable">Value</span>, ..., <span class="variable">Key</span> = <span class="variable">Value</span>}.</code></p>
<p>Values may be extracted from a record by using pattern matching:<br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#<span class="variable">Name</span>{<span class="variable">Key</span> = <span class="variable">Variable</span>, ..., <span class="variable">Key</span> = <span class="variable">Variable</span>} = <span class="variable">Record</span>.</code><br>
  This assigns to the Variables the corresponding Values in the Record.</p>
<p>Pattern matching may be used in function definitions:<br>
  <code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="variable">FunctionName</span>(#<span class="variable">Name</span>{<span class="variable">Key</span> = <span class="variable">Variable</span>, ..., <span class="variable">Key</span> = <span class="variable">Variable</span>} = <span class="variable">Variable</span>) -&gt; <span class="variable">FunctionBody</span>.</code><br>
  This makes the selected values, and the entire record (the last Variable) available in the function body.</p>
<p>A record is actually a tuple; the keys are just syntactic sugar available to the compiler. The function <code>rf(<span class="variable">Record</span>)</code> tells Erlang to drop the keys and treat the variable <span class="variable">Record</span> as the tuple <code>{<span class="variable">Name</span>, <span class="variable">Variable1</span>, ..., <span class="variable">VariableN</span>}</code>. This changes the <em>appearance</em> of the variable in the program, <em>not</em> its actual value.</p>
<h1><a name="process_dictionary"></a>The process dictionary</h1>
<p>The <span class="definiendum">process dictionary</span> is a private, <strong>mutable</strong> hash table that is private to the current process. Keys are atoms; the value associated with a key may be changed. The use of a process dictionary negates many of the advantages of a single-assignment functional language, hence its use is strongly discouraged. Supplied operations are:</p>
<dl>
  <dt><code>put(<span class="variable">Key</span>, <span class="variable">Value</span>) -&gt; <span class="variable">OldValue</span></code></dt>
  <dd>Associates the <span class="variable">Value</span> with the <span class="variable">Key</span>, returning the previous value associated with the <span class="variable">Key</span>, or the atom <code>undefined</code>.</dd>
  <dt><code>get(<span class="variable">Key</span>) -&gt; <span class="variable">Value</span></code></dt>
  <dd>Returns the <span class="variable">Value</span> currently associated with the <span class="variable">Key</span>, or the atom <code>undefined</code>.</dd>
  <dt><code>get() -&gt; [{<span class="variable">Key</span>, <span class="variable">Value</span>}, ..., {<span class="variable">Key</span>, <span class="variable">Value</span>}]</code></dt>
  <dd>Returns a list of all <span class="variable">Key</span>/<span class="variable">Value</span> tuples.</dd>
  <dt><code>get_keys(<span class="variable">Value</span>) -&gt; [<span class="variable">Key</span>, ..., <span class="variable">Key</span>]</code></dt>
  <dd>Returns a list of <span class="variable">Key</span>s having the given <span class="variable">Value</span>.</dd>
  <dt><code>erase(<span class="variable">Key</span>) -&gt; <span class="variable">Value</span></code></dt>
  <dd>Returns the <span class="variable">Value</span> currently associated with the <span class="variable">Key</span>, or the atom <code>undefined</code>, and removes the <span class="variable">Key</span>/<span class="variable">Value</span> pair from the process dictionary.</dd>
  <dt><code>erase() -&gt; [{<span class="variable">Key</span>, <span class="variable">Value</span>}, ..., {<span class="variable">Key</span>, <span class="variable">Value</span>}]</code></dt>
  <dd>Returns a list of all <span class="variable">Key</span>/<span class="variable">Value</span> tuples, and erases the contents of the process dictionary.</dd>
</dl>
<h1><a name="concurrency"></a>Concurrency </h1>
<p>Concurrent programming is very simple in Erlang. There are three primitives:</p>
<table width="100%" border="1" cellpadding="0" cellspacing="0" class="data">
  <tbody><tr>
    <th scope="col" width="50%">Primitive</th>
    <th scope="col">Description</th>
  </tr>
  <tr>
    <td valign="top"><code><span class="variable">Pid</span> = spawn(<span class="variable">Fun</span>)</code></td>
    <td valign="top"><p>Creates and starts new process ("Actor") and tells it to evaluate <span class="variable">Fun</span>. The new process is a <em><strong>very</strong></em> lightweight Thread, managed by Erlang, not an operating system process.</p>
      <p>A previously defined function may be passed in with the syntax <code>fun&nbsp;<span class="variable">FunctionName</span>/<span class="variable">arity</span></code>.</p></td>
  </tr>
  <tr>
    <td valign="top"><code><span class="variable">Pid</span> <strong>!</strong> <span class="variable">Message</span></code></td>
    <td valign="top">Sends the <span class="variable">Message</span> to the <span class="variable">Pid</span> process. This is an <span class="definiendum">asynchronous</span> operation, that is, execution continues without waiting for a reply. The value of the expression is the <span class="variable">Message</span> itself.</td>
  </tr>
  <tr>
    <td valign="top"><code>receive<br>
      &nbsp;&nbsp;<span class="variable">Pattern1</span> <span class="faded">[</span>when <span class="variable">Guard1</span><span class="faded">]</span> -&gt; <span class="variable">Expression_sequence1</span>;<br>
      <span class="variable"> &nbsp;&nbsp;Pattern2</span> <span class="faded">[</span>when <span class="variable">Guard2</span><span class="faded">]</span> -&gt; <span class="variable">Expression_sequence2</span>;<br>
      &nbsp;&nbsp;...<br>
      <span class="variable">&nbsp;&nbsp;PatternN</span> <span class="faded">[</span>when <span class="variable">GuardN</span><span class="faded">]</span> -&gt; <span class="variable">Expression_sequenceN</span><br>
      after <span class="variable">Timeout</span> -&gt;<br>
      &nbsp;&nbsp;<span class="variable">TimeoutExpressionSequence</span><br>
      end</code></td>
    <td valign="top"><p>The semantics are similar to that of the <code>case</code> expression. The syntax is a bit complex so that a process can handle messages of many different types.</p>
      <p>The <code>after</code> clause is optional. If used:</p>
      <ul>
        <li>A positive <span class="variable">Timeout</span> will cause Erlang to execute the <span class="variable">TimeoutExpressionSequence</span> if no message is received within that number of milliseconds.</li>
        <li>A zero <span class="variable">Timeout</span> will cause Erlang to handle a matching message, if any, then immediately execute the <span class="variable">TimeoutExpressionSequence</span>.</li>
        <li>A <span class="variable">Timeout</span> of the atom <code>infinity</code> will cause the <span class="variable">TimeoutExpressionSequence</span> to never be executed.</li>
      </ul>
      <p>If there are no patterns between <code>receive</code> and <code>after</code>, the statement "sleeps" for the given number of milliseconds.</p></td>
  </tr>
</tbody></table>
<p>Every process has a <span class="definiendum">mailbox</span>. Messages go into the mailbox on a first-come, first-served basis. When the receiving process examines the mailbox (with the <code>receive</code> statement), it takes the <strong>first</strong> message that can be matched by some <span class="variable">Pattern</span>, and executes the corresponding <span class="variable">Expression_sequence</span>. Unmatched messages are left in the mailbox.</p>
<p>To send a message to a process, you must know its process id (Pid). If you want the process to send you back a response, you must tell it your Pid, usually as part of the message; for example, <code>Pid&nbsp;!&nbsp;{MyPid,&nbsp;MessageData}</code>.</p>
<p>It is also possible to <span class="definiendum">register</span> a Pid, thus making it globally available. Here are the BIFs (built-in functions) for doing that:</p>
<ul>
  <li><code>register(<span class="variable">AnAtom</span>, <span class="variable">Pid</span>)</code> -- gives the <span class="variable">Pid</span> a globally accessible "name," <span class="variable">AnAtom</span>.</li>
  <li><code>unregister(<span class="variable">AnAtom</span>)</code> -- removes the registration. If a registered process dies, it is automatically unregistered.</li>
  <li><code>whereis(<span class="variable">AnAtom</span>) -&gt; <span class="variable">Pid</span> | undefined</code> -- gets the <span class="variable">Pid</span> of a registered process, or undefined if no such process.</li>
  <li><code>registered() -&gt; [<span class="variable">AnAtom</span> :: atom()]</code> -- returns a list of all registered processes.</li>
</ul>
<h1><a name="exceptions"></a>Exceptions</h1>
<p>In addition to exceptions resulting from program errors, there are three kinds of exceptions that the programmer can deliberately generate:</p>
<ul>
  <li><code>exit(<em>Reason</em>)</code> -- exits the current process, and broadcasts <code>{'EXIT', <span class="variable">Pid</span>, <span class="variable">Reason</span>}</code> to all linked processes.</li>
  <li><code>throw(<em>Reason</em>)</code> -- throws an exception that the caller might want to catch.</li>
  <li><code>erlang:error(<em>Reason</em>)</code> -- indicates a fatal error.</li>
</ul>
<p>Code which might throw an exception can be placed in a <code>try..catch</code> statement, with this syntax:</p>
<blockquote>
  <pre>try <span class="variable">FunctionOrExpressionSequence</span> of
    <span class="variable">Pattern1</span> <span class="faded">[</span>when <span class="variable">Guard1</span><span class="faded">]</span> -&gt; <span class="variable">Expressions1</span>;
    ...<span class="variable"></span>
catch
    <span class="variable">ExType1</span>:<span class="variable">ExPattern1</span><span class="faded"> [</span>when <span class="variable">ExGuard1</span><span class="faded">]</span> -&gt; <span class="variable">ExExpressions1</span>;
    ...
after
    <span class="variable">AfterExpressions</span>
end</pre>
</blockquote>
<p>and this semantics: </p>
<ul>
  <li>The <span class="variable">FunctionOrExpressionSequence</span> is evaluated,
    <ul>
      <li>If it completes successfully,
        <ul>
          <li>Its value is compared against the <span class="variable">Pattern</span>s, </li>
          <li>the <span class="variable">Expression</span> associated with the first matching <span class="variable">Pattern</span> is evaluated, and this is the value of the <code>try..catch</code>.
            <ul>
              <li>The <code>when</code> guards are optional.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>If an exception occurs,
        <ul>
          <li>The first matching <code>catch</code> clause is evaluated
            <ul>
              <li>The <span class="variable">ExType</span>s must be one of <code>throw</code> (default if omitted), <code>exit</code>, or <code>error</code>.
                <ul>
                  <li>Special case: The syntax<code> _:_ </code>will catch every possible exception.</li>
                </ul>
              </li>
              <li>The value of the <code>try..catch</code> is the value of the corresponding <span class="variable">ExExpression</span>.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>In any event, the (optional) <span class="variable">AfterExpressions</span> are executed, but the resulting value is discarded.</li>
</ul>
<h1><a name="io"></a>Input/Output</h1>
<p>As with most languages, there are a lot of I/O routines. Files can be read as binary, as a sequence of lines, or as Erlang terms. This paper describes only line-oriented I/O.</p>
<p>On output, data is interpolated (inserted) into the <em>FormatString</em> at the following locations (excluding <code>~n</code>):</p>
<ul>
  <li><code>~s&nbsp;&nbsp;&nbsp;</code>Print as a string.</li>
  <li><code>~w&nbsp;&nbsp;&nbsp;</code>Print any value in "standard syntax". Strings are printed as lists of integers.</li>
  <li><code>~p&nbsp;&nbsp;&nbsp;</code>Pretty print any value (breaking lines, indenting, etc.)</li>
  <li><code>~n&nbsp;&nbsp;&nbsp;</code>Print a newline.</li>
</ul>
<h2><a name="console_input"></a>Input from the console</h2>
<blockquote>
  <p><code><span class="variable">Line</span> = io:get_line(<span class="variable">Prompt</span>). <span class="comment">% Prompt is a string or an atom</span></code></p>
</blockquote>
<h2><a name="console_output"></a>Output to the console</h2>
<blockquote>
  <p><code>io:format(<span class="variable">FormatString</span>, <span class="variable">ListOfData</span>).</code></p>
</blockquote>
<h2><a name="file_input"></a>Input from a file</h2>
<blockquote>
  <code>{ok, <span class="variable">Stream</span>} = file:open(<span class="variable">FileName</span>, read).<br>
<span class="variable">Line</span> = io:get_line(<span class="variable">S</span>, ''). <span class="comment">% May return eof</span><br>
file:close(<span class="variable">S</span>)</code>
</blockquote>
<h2><a name="file_output"></a>Output to a file</h2>
<blockquote>
  <code>{ok, <span class="variable">Stream</span>} = file:open(<span class="variable">FileName</span>, write).<br>
io:format(<span class="variable">S</span>, <span class="variable">FormatString</span>, <span class="variable">ListOfData</span>).<br>
file:close(<span class="variable">S</span>).</code>
</blockquote>
<h2><a name="unix"></a>Unix-like commands</h2>
<dl>
  <dt><code>cd("<em>path/to/directory</em>").</code></dt>
  <dd>Change directory. Uses forward slashes (/) even on Windows, and argument must be quoted. Responds <code>ok</code> <em>even if given a bad path,</em> so look </dd>
  <dt><code>pwd().</code></dt>
  <dd>Prints the working directory.</dd>
  <dt><code>ls().</code></dt>
  <dd>Prints the contents of the current directory.</dd>
  <dt><code>ls("<em>path/to/directory</em>").</code></dt>
  <dd>Prints the contents of the given directory. </dd>
  <dd>&nbsp; </dd>
</dl>
<h1><a name="unit_testing"></a>Unit Testing</h1>
<p>Unit tests can be put in the same file (module) as the functions being tested, or they can be placed in a separate file. Tests in a separate file have access only to the functions being exported.</p>
<p>To do unit testing, include the declaration
</p><blockquote><code>-include_lib("eunit/include/eunit.hrl").</code></blockquote>
Test functions must have a name ending in <code>_test_</code>. The body of the test function is typically a list of calls to an assert function. Some assert functions are:
<p></p>
<ul>
  <li><code>?_assert(<em>BoolExpression</em>)</code></li>
  <li><code>?_assertNot(<em>BooleanExpression</em>)</code></li>
  <li><code>?_assertMatch(<em>GuardedPattern</em>, <em>Expression</em>)</code></li>
  <li><code>?_assertEqual(<em>ExpectedValue</em>, <em>Expression</em>)</code></li>
  <li><code>?_assertException(<em>ClassPattern</em>, <em>TermPattern</em>, <em>Expression</em>)</code></li>
  <li><code>?_assertError(<em>TermPattern</em>, <em>Expression</em>)</code></li>
  <li><code>?_assertExit(<em>TermPattern</em>, <em>Expression</em>)</code></li>
  <li><code>?_assertThrow(<em>TermPattern</em>, <em>Expression</em>)</code></li>
</ul>
<p>Detailed information is available at <a href="http://www.erlang.org/doc/apps/eunit/">http://www.erlang.org/doc/apps/eunit/</a>.</p>


</body></html>